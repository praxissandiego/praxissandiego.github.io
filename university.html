<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Praxis Community University</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Space Mono', monospace;
            background-color: #f8fafb;
            color: #333;
            line-height: 1.6;
            padding: 2rem 0;
            position: relative;
            overflow-x: hidden;
        }

        /* Canvas background */
        #backgroundCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        /* Animation toggle button */
        #animationToggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #000;
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            z-index: 1000;
            transition: background-color 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        #animationToggle:hover {
            background-color: #333;
        }

        #animationToggle.paused {
            background-color: #666;
        }

        .container {
            max-width: 950px;
            margin: 0 auto;
            padding: 0 2rem;
            position: relative;
            background-color: #f8fafb;
            z-index: 1;
        }

        header {
            margin-bottom: 3rem;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        h1 {
            font-size: 2.5rem;
            letter-spacing: 0.1rem;
            font-weight: 700;
        }

        .back-link {
            color: #2563eb;
            text-decoration: none;
            font-weight: 700;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .description {
            margin-bottom: 2rem;
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .search-box {
            flex: 1;
            min-width: 300px;
        }

        .search-box input {
            width: 100%;
            font-family: 'Space Mono', monospace;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .table-wrapper {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid #eee;
            vertical-align: top;
        }


        th:nth-child(1), td:nth-child(1) { width: 33%; }
        th:nth-child(2), td:nth-child(2) { width: 20%; }
        th:nth-child(3), td:nth-child(3) { width: 28%; }
        th:nth-child(4), td:nth-child(4) { width: 19%; }

        .class-name {
            font-weight: 700;
            margin-bottom: 0.3rem;
        }

        .class-description {
            font-size: 0.9rem;
            color: #666;
            line-height: 1.4;
        }

        th {
            background-color: #f5f5f5;
            font-weight: 700;
            cursor: pointer;
            user-select: none;
            position: sticky;
            top: 0;
            z-index: 10;
            vertical-align: top;
        }

        th:hover {
            background-color: #ebebeb;
        }

        th::after {
            content: ' ↕';
            opacity: 0.3;
            font-size: 0.8em;
        }

        th.sort-asc::after {
            content: ' ↑';
            opacity: 1;
        }

        th.sort-desc::after {
            content: ' ↓';
            opacity: 1;
        }

        tr:hover {
            background-color: #f9f9f9;
        }

        td a {
            color: #2563eb;
            text-decoration: none;
        }

        td a:hover {
            text-decoration: underline;
        }

        .stats {
            margin-top: 1rem;
            color: #666;
            font-size: 0.9rem;
        }

        @media (max-width: 1000px) {
            .container {
                padding: 0 1rem;
            }

            h1 {
                font-size: 1.8rem;
            }

            .table-wrapper {
                overflow-x: auto;
            }

            table {
                min-width: 600px;
            }
        }
    </style>

    <script src="classes/fall2025/link-conversion.js" defer></script>
</head>
<body>
    <canvas id="backgroundCanvas"></canvas>
    <button id="animationToggle">⏻︎</button>

    <div class="container">
        <header>
            <div class="header-content">
                <h1>Praxis Community University</h1>
                <a href="index.html" class="back-link">← to Praxis SD</a>
            </div>
        </header>

        <div class="description">
            <p>
              We want to have a place where people can teach and learn from each other for fun in a setting outside of traditional academia —— a community university —— so we are starting one! Our goal is to create an environment where learning is enjoyable, by-the-community and for-the-community, and as widely accessible as possible. We are inspired by learning places like <a href="https://fractaluniversity.substack.com/about">Fractal U NYC</a>,
              <a href="https://www.schoolofattention.org/">Strother School of Radical Attention</a>,
              <a href="https://shoshincollege.org/">Shoshin College</a>,
              <a href="https://antiuniversity.org/">AntiUniversity Now</a> and other similar efforts across the world.
              <br><br>
              You can find the classes available in our Fall 2025 term and information about them below. <b><u>The Fall 2025 term starts October 4. The <a href="#apply">registration</a> is open until October 3.</u></b>
              If you have any questions, don't hesitate to <a id="link-conversion" rel="nofollow, noindex" href="t:::o-praxi:-ssan:dieg:o_gma-il/com"> email us</a>!
              <br><br>
              Join us to learn from your peers, neighbors, and friends, meet others interested in the same things as you, get useful knowledge, and have fun along the way!
            </p>
        </div>

        <div class="controls">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Search by title, author, or keyword...">
            </div>
        </div>

        <div class="table-wrapper">
            <table id="archiveTable">
                <thead>
                    <tr>
                        <th data-column="0">Class & Description<br>(Click for Info)</th>
                        <th data-column="1">Instructor(s)</th>
                        <th data-column="2">Days, Times, and Dates</th>
                        <th data-column="3">Location</th>
                    </tr>
                </thead>
                <tbody id="archiveTableBody">
                    <!-- Data loaded here -->
                </tbody>
            </table>
        </div>

        <div class="stats">
            <span id="visibleCount">20</span> of <span id="totalCount">20</span> entries shown
        </div>

        <br><br>

        <h2 id="apply">Application Form</h2>

        <div class="form-embed" id="formContainer">
            <iframe
                src="https://tally.so/embed/mKXVpM?alignLeft=1&hideTitle=1&transparentBackground=1&dynamicHeight=1"
                width="100%"
                height="600"
                frameborder="0"
                marginheight="0"
                marginwidth="0"
                title="Application Form">
            </iframe>
            <!--<iframe data-tally-src="https://tally.so/embed/mKXVpM?alignLeft=1&hideTitle=1&transparentBackground=1&dynamicHeight=1" loading="lazy" width="100%" height="1109" frameborder="0" marginheight="0" marginwidth="0" title="Praxis Community University
Fall 2025 Application Form"></iframe>-->
            <script>var d=document,w="https://tally.so/widgets/embed.js",v=function(){"undefined"!=typeof Tally?Tally.loadEmbeds():d.querySelectorAll("iframe[data-tally-src]:not([src])").forEach((function(e){e.src=e.dataset.tallySrc}))};if("undefined"!=typeof Tally)v();else if(d.querySelector('script[src="'+w+'"]')==null){var s=d.createElement("script");s.src=w,s.onload=v,s.onerror=v,d.body.appendChild(s);}</script>
        </div>
    </div>

    <script>
        // Initialize variables
        let allData = [];
        let filteredData = [];

        // Load data from JSON file
        async function loadData() {
            try {
                const response = await fetch('data/classes-current.json');
                allData = await response.json();
                filteredData = [...allData];

                // Update total count
                document.getElementById('totalCount').textContent = allData.length;

                // Populate table
                populateTable(allData);

                // Initialize filters and sorting
                initializeControls();

            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('archiveTableBody').innerHTML =
                    '<tr><td colspan="5">Unable to load data. Please check data files.</td></tr>';
            }
        }

        // Populate table with data
        function populateTable(data) {
            const tbody = document.getElementById('archiveTableBody');
            tbody.innerHTML = '';

            data.forEach(item => {
                const row = document.createElement('tr');

                row.id = item.id || item.name.toLowerCase().replace(/[^a-z0-9]+/g, '-');

                row.innerHTML = `
                    <td>
                        <div class="class-name"><a href="${item.link}">${item.name}</a></div>
                        <div class="class-description">${item.description}</div>
                    </td>
                    <td>${item.instructor}</td>
                    <td>${item.when}</td>
                    <td>${item.where}</td>
                `;
                tbody.appendChild(row);
            });

            // Update visible count
            document.getElementById('visibleCount').textContent = data.length;
        }

        // Initialize controls
        function initializeControls() {
            const searchInput = document.getElementById('searchInput');
            const headers = document.querySelectorAll('th');

            // Search functionality
            searchInput.addEventListener('input', filterTable);

            // Sorting functionality
            headers.forEach(header => {
                header.sortState = 'none'; // Track sort state: none, asc, desc

                header.addEventListener('click', function() {
                    const column = parseInt(this.dataset.column);

                    // Cycle through states: none -> asc -> desc -> none
                    if (this.sortState === 'none') {
                        this.sortState = 'asc';
                    } else if (this.sortState === 'asc') {
                        this.sortState = 'desc';
                    } else {
                        this.sortState = 'none';
                    }

                    // Remove sort classes from all headers
                    headers.forEach(h => {
                        h.classList.remove('sort-asc', 'sort-desc');
                        if (h !== this) h.sortState = 'none'; // Reset other columns
                    });

                    // Apply appropriate class
                    if (this.sortState === 'asc') {
                        this.classList.add('sort-asc');
                    } else if (this.sortState === 'desc') {
                        this.classList.add('sort-desc');
                    }

                    // Sort data
                    if (this.sortState === 'none') {
                        // Return to original order
                        filteredData = [...allData];
                        filterTable(); // Re-apply any active filters
                    } else {
                        sortData(column, this.sortState === 'asc');
                    }
                });
            });
        }

        // Filter table
        function filterTable() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();

            filteredData = allData.filter(item => {
                const matchesSearch =
                    item.name.toLowerCase().includes(searchTerm) ||
                    item.description.toLowerCase().includes(searchTerm) ||
                    item.instructor.toLowerCase().includes(searchTerm) ||
                    item.when.toLowerCase().includes(searchTerm) ||
                    item.where.toLowerCase().includes(searchTerm);

                return matchesSearch;
            });

            populateTable(filteredData);
        }

        // Sort data
        function sortData(column, ascending) {
            const fields = ['name', 'instructor', 'whenSort1', 'where'];
            const displayFields = ['name', 'instructor', 'when', 'where'];

            let field = fields[column];
            let displayField = displayFields[column];

            filteredData.sort((a, b) => {
                // Use whenSort1 for sorting but display when
                let aVal = field === 'whenSort1' ? (a[field] || a.when) : a[displayField];
                let bVal = field === 'whenSort1' ? (b[field] || b.when) : b[displayField];

                // Convert to lowercase for string comparison
                if (typeof aVal === 'string') aVal = aVal.toLowerCase();
                if (typeof bVal === 'string') bVal = bVal.toLowerCase();

                if (ascending) {
                    return aVal > bVal ? 1 : -1;
                } else {
                    return aVal < bVal ? 1 : -1;
                }
            });

            populateTable(filteredData);
        }

        class TriangularMeshBackground {
            constructor() {
                this.canvas = document.getElementById('backgroundCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.nodes = [];
                this.time = 0;
                this.contentWidth = 900; // Max width of content
                this.contentPadding = 50; // Extra padding around content
                this.isAnimating = true;

                this.init();
                this.animate();

                // Handle resize
                window.addEventListener('resize', () => this.init());

                // Handle animation toggle
                const toggleBtn = document.getElementById('animationToggle');
                toggleBtn.addEventListener('click', () => {
                    this.isAnimating = !this.isAnimating;
                    toggleBtn.textContent = this.isAnimating ? '⏻︎' : '⏻︎';
                    toggleBtn.classList.toggle('paused', !this.isAnimating);
                });
            }

            init() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                // Clear existing nodes
                this.nodes = [];

                // Calculate content area to avoid
                const contentLeft = (this.canvas.width - this.contentWidth) / 2 - this.contentPadding;
                const contentRight = (this.canvas.width + this.contentWidth) / 2 + this.contentPadding;

                // Create irregular triangular grid with more randomness
                const baseSpacing = 60; // Base distance between nodes
                const rows = Math.ceil(this.canvas.height / (baseSpacing * 0.866)) + 2;
                const cols = Math.ceil(this.canvas.width / baseSpacing) + 2;

                for (let row = -1; row < rows; row++) {
                    for (let col = -1; col < cols; col++) {
                        // Add significant randomness to positions
                        const randomOffsetX = (Math.random() - 0.5) * baseSpacing * 0.6;
                        const randomOffsetY = (Math.random() - 0.5) * baseSpacing * 0.6;

                        const x = col * baseSpacing + (row % 2) * (baseSpacing / 2) + randomOffsetX;
                        const y = row * baseSpacing * 0.866 + randomOffsetY;

                        // Only add nodes that are outside the content area
                        if (x < contentLeft || x > contentRight) {
                            this.nodes.push({
                                x: x,
                                y: y,
                                baseX: x,
                                baseY: y,
                                offsetX: Math.random() * 15 - 7.5,
                                offsetY: Math.random() * 15 - 7.5,
                                phase: Math.random() * Math.PI * 2,
                                amplitude: 8 + Math.random() * 12, // Increased amplitude for more noticeable sway
                                speed: 0.8 + Math.random() * 0.4 // Variable speed for each node
                            });
                        }
                    }
                }

                // Store content boundaries for connection drawing
                this.contentLeft = contentLeft;
                this.contentRight = contentRight;
                this.spacing = baseSpacing;
            }

            drawConnections() {
                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)'; // Black edges
                this.ctx.lineWidth = 1;

                // Draw connections between nearby nodes
                for (let i = 0; i < this.nodes.length; i++) {
                    const node1 = this.nodes[i];

                    for (let j = i + 1; j < this.nodes.length; j++) {
                        const node2 = this.nodes[j];
                        const dist = Math.sqrt(
                            Math.pow(node2.x - node1.x, 2) +
                            Math.pow(node2.y - node1.y, 2)
                        );

                        // Connect nodes that are close (using current positions for more organic look)
                        if (dist < this.spacing * 1.5) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(node1.x, node1.y);
                            this.ctx.lineTo(node2.x, node2.y);
                            this.ctx.stroke();
                        }
                    }
                }
            }

            animate() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Update node positions only if animating
                if (this.isAnimating) {
                    this.time += 0.015; // Slightly faster for more noticeable movement
                }

                this.nodes.forEach(node => {
                    if (this.isAnimating) {
                        node.x = node.baseX + node.offsetX +
                               Math.sin(this.time * node.speed + node.phase) * node.amplitude;
                        node.y = node.baseY + node.offsetY +
                               Math.cos(this.time * node.speed * 0.7 + node.phase) * node.amplitude * 0.7;
                    }
                });

                // Draw connections first
                this.drawConnections();

                // Draw nodes in black
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; // Black nodes
                this.nodes.forEach(node => {
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, 2.5, 0, Math.PI * 2); // Slightly larger nodes
                    this.ctx.fill();
                });

                requestAnimationFrame(() => this.animate());
            }
        }

        // Load data when page loads
        /*document.addEventListener('DOMContentLoaded', loadData);*/
        // Load data when page loads
        document.addEventListener('DOMContentLoaded', () => {
            loadData();
            new TriangularMeshBackground();
        });
    </script>
</body>
</html>
